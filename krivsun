1. Дана таблица значений булевой функции от 2-х переменных, например 1011
Узнать по ней её номер (f0... f15)

Ответ: рассмотреть её таблицу значений как двоичный код натурального числа и
       перевести

parseInt('1011',2 )

2. Как решить обратную задачу?

(11).toString(2).padStart(8, '0')

3. Дано: представление числа без знака в виде октета

10110100  - пример в двоичном виде

Как используя булеву функцию узнать, чётно ли оно?

Сформулируйте критерий - однозначное условие, по которому определяется чётность.


  xxxxxxx0
& 00000001

Число чётное, если получается 0
иначе нечётное

const even = testedValue => testedValue  & 0b00000001;

ИЛИ как вариант

const even2 = testedValue => testedValue | 0b11111110;

критерий: эта функция возвращает для чётных чисел свою собственную маску

4. Как проверить с помощью булевой функции, что в октете установлен конкретный бит (с номером n)?
(n = 0...7 и оно является аргументом функции)
...
const even3 = (testedValue,n) => testedValue & 2**n

5.

Для каких диапазонов чисел из отрезка [0..33] 
эта функция будет возвращать число 8?

Array.from({length:34}, (v,i)=>i).map( (x,i)=> (  {i, v: even3(x,3)}) )

6. Дано представление числа в виде октета в диапазон от 0 до 63

как получить его удвоение без арифметических операций, работая только с битами?

00000101

00001010

(0b0000101 << 1).toString(2).padStart(8, '0')
'00001010'

СДВИГ

7. Мы  знаем, что повторное применение отрицания возвращает то же значение, которое подвергалось первичному отрицанию.

f(f(a)) = a

Приведите пример из числа булевых функций двух переменных, обладающих тем же свойством.

f(f(a,b),b) = a
